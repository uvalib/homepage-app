<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../uvalib-helper-libs/lodash.html">

<dom-module id="uvalib-articles">
  <template>
    <iron-ajax id="ajax" active-requests="{{activeRequests}}" auto="{{auto}}" bubbles="{{bubbles}}"
      debounce-duration="{{debounceDuration}}" last-error="{{lastError}}" last-request="{{lastRequest}}"
      last-response="{{lastResponse}}" loading="{{loading}}" params="{{_params}}" sync="{{sync}}"
      timeout="{{timeout}}" url="{{_url}}" verbose="{{verbose}}"
      on-error="_handleError" on-request="_handleRequest" on-response="_handleResponse"
      handle-as="json"></iron-ajax>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'uvalib-articles',
        properties: {
          activeRequests: {
            type: Array,
            notify: true,
            readOnly: true,
            value: function() {
              return [];
            }
          },

          /**
           * If true, automatically performs an Ajax request when either `url` or
           * `params` changes.
           */
          auto: {
            type: Boolean,
            value: false
          },

          /**
           * By default, these events do not bubble largely because the `error` event has special
           * meaning in the window object. Setting this attribute will cause iron-ajax's request,
           * response, and error events to bubble to the window object.
           */
          bubbles: {
            type: Boolean,
            value: false
          },

          /**
           * Number of results in the last response
           */
          count: {
            type: Number,
            value: 0,
            notify: true,
            readOnly: true
          },

          /**
           * Length of time in milliseconds to debounce multiple automatically generated requests.
           */
          debounceDuration: {
            type: Number,
            value: 0,
            notify: true
          },

          /**
           * Defines the filters that should be used (from the available filters)
           */
          filters: {
            type: Array,
            value: function(){
              return [{orig:'SubjectEDS',new:'subject',name:'Subject'},
                      {orig:'SubjectGeographic',new:'region',name:'Geographic Location'},
                      {orig:'Journal',new:'journal',name:'Journal'},
                      {orig:'Language',new:'language',name:'Language'},
                      {orig:'Publisher',new:'publisher',name:'Publisher'},
                      {orig:'SourceType',new:'sourcetype',name:'Source Type'},
                      {orig:'ContentProvider',new:'source',name:'Source'}
                    ];
            },
            notify: true,
            readOnly: true
          },

          /**
           * The items from the Catalog request, in a normalized/simplified Format
           */
          items: {
            type: Array,
            value: [],
            notify: true,
            readOnly: true
          },

          /**
           * lastRequest's error, if any.
           *
           * @type {Object}
           */
          lastError: {
            type: Object,
            notify: true,
            readOnly: true
          },

          /**
           * The most recent request made by this iron-ajax element.
           */
          lastRequest: {
            type: Object,
            notify: true,
            readOnly: true
          },

          /**
           * lastRequest's response.
           *
           * Note that lastResponse and lastError are set when lastRequest finishes,
           * so if loading is true, then lastResponse and lastError will correspond
           * to the result of the previous request.
           *
           * The type of the response is determined by the value of `handleAs` at
           * the time that the request was generated.
           *
           * @type {Object}
           */
          lastResponse: {
            type: Object,
            notify: true,
            readOnly: true
          },

          /**
           * The query string of the search
           */
          query: {
            type: String,
            notify: true,
            value: "",
            observer: "_queryChanged"
          },

          /**
           * Toggle whether XHR is synchronous or asynchronous. Don't change this
           * to true unless You Know What You Are Doingâ„¢.
           */
          sync: {
            type: Boolean,
            value: false
          },

          /**
           * Set the timeout flag on the request.
           */
          timeout: {
            type: Number,
            value: 0
          },

          /**
           * If true, error messages will automatically be logged to the console.
           */
          verbose: {
            type: Boolean,
            value: false
          },

          /**
           * True while lastRequest is in flight.
           */
          loading: {
            type: Boolean,
            notify: true
          },

          /**
           * Length of time in milliseconds to debounce multiple automatically generated requests.
           */
          debounceDuration: {
            type: Number,
            value: 0,
            notify: true
          },

          _url: {
            type: String,
            value: "http://api.library.virginia.edu/articles.json"
          },

          _params: {
            type: Object,
            value: {q:'*'},
            notify: true
          }
        },
        ready: function(){
          this._filterValueMap = {};
        },
        _handleError: function(){
          this.fire('error');
        },
        _handleRequest: function(){
          this.fire('request');
        },
        _handleResponse: function(){
          if (this.$.ajax.lastResponse) {
            this._setItems(this._mapResults(this.$.ajax.lastResponse.docs));
            this._setCount(this.$.ajax.lastResponse.response.numFound);
            this.fire('response');
          }
        },
        _queryChanged: function(){
          if (this._params) {
            this.set('_params.q', this.query? this.query:'*');
          }
        },
        _mapResults: function(items){
          return _.map(items,function(item){
            return {id: item.issn+"-"+item.header.an,
                    title: item.display.title,
                    author: item.display.creator,
                    format: item.display.type}
          });
        },
        generateRequest: function(){
          this.$.ajax.generateRequest();
        },
        areFiltersAvailable: function(selFilters){
          var filters = this.getFilters();
          for (var key in selFilters) {
            var filter = _.find(filters,{id:key});
            if (filter) {
              selFilters[key].forEach(function(val){
                if (!_.find(filter.values,{id:val}))
                  return false
              }, this);
            } else {
              return false;
            }
          }
          return true;
        },
        emptyFilters: function(){
          for (var key in this._params) {
            if (key.startsWith('f['))
              delete this._params[key];
          }
        },
        setSelectedFilters: function(selFilters){
          this.emptyFilters();
          if (!_.isEmpty(selFilters)) {
            for (var key in selFilters) {
              var filter = _.find(this.filters,{new:key});
              if (filter) {
                selFilters[key].forEach(function(val){
                  this.set('_params.f['+filter.orig+'][]', this._filterValueMap[filter.new][val]);
                }, this);
              }
            }
          }
        },
        getFilters: function(){
          return this._mapFilters(this.$.ajax.lastResponse.facets);
        },
        _mapFilters: function(fields){
          var facets = []
          this.filters.forEach(function(filter,i){
            if (_.findIndex(fields,{'name':filter.orig})>-1)
              this._filterValueMap[filter.new] = {};
              facets.push({
                id: filter.new,
                name: filter.name,
                values: _.map(_.find(fields, {name:filter.orig}).items,
                              function(i){
                                var id = i.value.replace(/\s/g,'_').toLowerCase();
                                this._filterValueMap[filter.new][id] = i.value;
                                return {id:id, name:i.value, count:i.hits};
                              }.bind(this))
              });
          }, this);
          return facets;
        },
      });
    })();
  </script>
</dom-module>
